# IoT 组态控制面板 - 组件开发手册

## 1. 概述

本手册详细介绍如何为组态系统开发自定义组件，包括组件定义、渲染实现、属性配置、数据绑定和事件处理。

## 2. 组件开发流程

```
1. 在 widgetConfig.ts 中定义组件配置
2. 在 WidgetRenderer.vue 中实现组件渲染
3. 添加组件样式
4. 测试组件功能
```

## 3. 组件定义详解

### 3.1 基本结构

在 `widgetConfig.ts` 中添加组件定义：

```typescript
{
  type: 'myWidget',           // 唯一标识，用于区分组件类型
  name: '我的组件',            // 显示名称
  category: 'basic',          // 所属分类
  icon: 'AppstoreOutlined',   // 图标名称（Ant Design Icons）
  defaultSize: {              // 默认尺寸
    width: 200,
    height: 100,
  },
  props: { ... },             // 可配置属性
  binding: { ... },           // 数据绑定配置
  events: [ ... ],            // 事件配置
}
```

### 3.2 属性配置 (props)

属性定义了组件可配置的参数，会在属性编辑器中显示。

```typescript
props: {
  // 字符串类型
  title: {
    type: 'string',
    default: '标题',
    label: '标题文字',
  },
  
  // 数字类型
  fontSize: {
    type: 'number',
    default: 14,
    label: '字体大小',
    min: 10,        // 最小值
    max: 72,        // 最大值
  },
  
  // 布尔类型
  showIcon: {
    type: 'boolean',
    default: true,
    label: '显示图标',
  },
  
  // 选择类型
  size: {
    type: 'select',
    default: 'middle',
    label: '尺寸',
    options: ['large', 'middle', 'small'],
  },
  
  // 颜色类型
  color: {
    type: 'color',
    default: '#1890ff',
    label: '颜色',
  },
  
  // 数组类型（复杂配置）
  options: {
    type: 'array',
    default: [
      { label: '选项1', value: '1' },
      { label: '选项2', value: '2' },
    ],
    label: '选项列表',
  },
  
  // 图标选择
  iconName: {
    type: 'icon',
    default: 'BulbOutlined',
    label: '图标',
  },
}
```

### 3.3 数据绑定配置 (binding)

#### 简单绑定（单点位）

```typescript
binding: {
  supportDataBinding: true,      // 支持数据绑定
  dataType: 'number',            // 数据类型
  bindingLabel: '绑定数值点位',   // 绑定标签
}
```

#### 多点位绑定

```typescript
binding: {
  points: [
    { key: 'power', label: '电源状态', dataType: 'boolean' },
    { key: 'temperature', label: '温度', dataType: 'number' },
    { key: 'mode', label: '模式', dataType: 'string' },
  ],
}
```

### 3.4 事件配置 (events)

```typescript
events: [
  {
    key: 'click',           // 事件标识
    name: '点击事件',        // 显示名称
    supportHttp: true,      // 支持HTTP请求
  },
  {
    key: 'change',
    name: '值变化',
    supportHttp: true,
    params: ['value'],      // 事件参数
  },
  {
    key: 'modeChange',
    name: '模式切换',
    supportHttp: true,
    params: ['mode', 'previousMode'],
  },
]
```

## 4. 组件渲染实现

### 4.1 在 WidgetRenderer.vue 中添加模板

```vue
<template>
  <div class="widget-renderer">
    <!-- 其他组件... -->
    
    <!-- 我的自定义组件 -->
    <template v-else-if="widget.type === 'myWidget'">
      <div class="my-widget">
        <div class="my-widget-header">
          <span class="title">{{ widget.props?.title || '标题' }}</span>
          <component 
            v-if="widget.props?.showIcon" 
            :is="getIconComponent(widget.props?.iconName)" 
          />
        </div>
        <div 
          class="my-widget-content"
          :style="{ 
            fontSize: `${widget.props?.fontSize || 14}px`,
            color: widget.props?.color || '#333'
          }"
        >
          {{ displayValue }}
        </div>
        <div class="my-widget-footer">
          <a-button 
            :size="widget.props?.size || 'middle'"
            :disabled="isDesign"
            @click="handleClick"
          >
            操作
          </a-button>
        </div>
      </div>
    </template>
    
    <!-- 默认占位... -->
  </div>
</template>
```

### 4.2 添加组件状态和逻辑

```typescript
// 在 <script setup> 中添加

// 组件内部状态
const myWidgetState = reactive({
  value: 0,
  mode: 'normal',
});

// 计算显示值
const displayValue = computed(() => {
  // 如果有数据绑定，从 shadowState 获取
  if (props.widget.binding?.point && props.shadowState) {
    return props.shadowState[props.widget.binding.point] ?? '--';
  }
  return myWidgetState.value;
});

// 监听影子状态变化
watch(() => props.shadowState, (newState) => {
  if (!newState || props.isDesign) return;
  
  const binding = props.widget.binding;
  
  // 多点位绑定
  if (props.widget.type === 'myWidget' && binding?.points) {
    if (binding.points.power && newState[binding.points.power] !== undefined) {
      myWidgetState.power = !!newState[binding.points.power];
    }
    // ... 其他点位
  }
}, { deep: true, immediate: true });

// 事件处理
function handleClick() {
  if (props.isDesign) return;
  triggerEvent('click', {});
}

function handleValueChange(value: any) {
  if (props.isDesign) return;
  myWidgetState.value = value;
  triggerEvent('change', { value });
}
```

### 4.3 添加样式

```less
// 在 <style> 中添加

.my-widget {
  width: 100%;
  height: 100%;
  padding: 12px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 8px;
  color: #fff;
  display: flex;
  flex-direction: column;
  
  .my-widget-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    
    .title {
      font-size: 14px;
      font-weight: 500;
    }
  }
  
  .my-widget-content {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    font-weight: bold;
  }
  
  .my-widget-footer {
    display: flex;
    justify-content: center;
    margin-top: 8px;
  }
}
```

## 5. 完整示例：智能窗帘控制组件

### 5.1 组件定义

```typescript
// widgetConfig.ts
{
  type: 'curtainControl',
  name: '窗帘控制',
  category: 'hvac',  // 或创建新分类
  icon: 'ColumnWidthOutlined',
  defaultSize: { width: 200, height: 150 },
  props: {
    title: { type: 'string', default: '窗帘', label: '标题' },
    showPercent: { type: 'boolean', default: true, label: '显示百分比' },
    minPosition: { type: 'number', default: 0, label: '最小位置', min: 0, max: 100 },
    maxPosition: { type: 'number', default: 100, label: '最大位置', min: 0, max: 100 },
  },
  binding: {
    points: [
      { key: 'position', label: '当前位置', dataType: 'number' },
      { key: 'moving', label: '运动状态', dataType: 'boolean' },
    ],
  },
  events: [
    { key: 'open', name: '打开', supportHttp: true },
    { key: 'close', name: '关闭', supportHttp: true },
    { key: 'stop', name: '停止', supportHttp: true },
    { key: 'setPosition', name: '设置位置', supportHttp: true, params: ['position'] },
  ],
}
```

### 5.2 渲染模板

```vue
<!-- 窗帘控制组件 -->
<template v-else-if="widget.type === 'curtainControl'">
  <div class="curtain-control-widget">
    <div class="curtain-header">
      <span class="curtain-title">{{ widget.props?.title || '窗帘' }}</span>
      <span v-if="curtainState.moving" class="moving-indicator">
        <LoadingOutlined spin />
      </span>
    </div>
    
    <div class="curtain-visual">
      <div class="curtain-track">
        <div 
          class="curtain-fabric" 
          :style="{ width: `${curtainState.position}%` }"
        ></div>
      </div>
      <span v-if="widget.props?.showPercent" class="curtain-percent">
        {{ curtainState.position }}%
      </span>
    </div>
    
    <div class="curtain-slider">
      <a-slider
        v-model:value="curtainState.position"
        :min="widget.props?.minPosition || 0"
        :max="widget.props?.maxPosition || 100"
        :disabled="isDesign"
        @afterChange="handlePositionChange"
      />
    </div>
    
    <div class="curtain-buttons">
      <a-button size="small" :disabled="isDesign" @click="handleOpen">
        <template #icon><UpOutlined /></template>
        开
      </a-button>
      <a-button size="small" :disabled="isDesign" @click="handleStop">
        <template #icon><PauseOutlined /></template>
        停
      </a-button>
      <a-button size="small" :disabled="isDesign" @click="handleClose">
        <template #icon><DownOutlined /></template>
        关
      </a-button>
    </div>
  </div>
</template>
```

### 5.3 组件逻辑

```typescript
// 窗帘状态
const curtainState = reactive({
  position: 0,
  moving: false,
});

// 监听影子状态
watch(() => props.shadowState, (newState) => {
  if (!newState || props.isDesign) return;
  
  if (props.widget.type === 'curtainControl') {
    const binding = props.widget.binding;
    if (binding?.points?.position && newState[binding.points.position] !== undefined) {
      curtainState.position = Number(newState[binding.points.position]);
    }
    if (binding?.points?.moving && newState[binding.points.moving] !== undefined) {
      curtainState.moving = !!newState[binding.points.moving];
    }
  }
}, { deep: true, immediate: true });

// 事件处理
function handleOpen() {
  if (props.isDesign) return;
  triggerEvent('open', {});
}

function handleClose() {
  if (props.isDesign) return;
  triggerEvent('close', {});
}

function handleStop() {
  if (props.isDesign) return;
  triggerEvent('stop', {});
}

function handlePositionChange(value: number) {
  if (props.isDesign) return;
  triggerEvent('setPosition', { position: value });
}
```

### 5.4 组件样式

```less
.curtain-control-widget {
  width: 100%;
  height: 100%;
  padding: 12px;
  background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  
  .curtain-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    
    .curtain-title {
      font-size: 14px;
      font-weight: 500;
      color: #333;
    }
    
    .moving-indicator {
      color: #1890ff;
    }
  }
  
  .curtain-visual {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    
    .curtain-track {
      width: 80%;
      height: 40px;
      background: #f0f0f0;
      border-radius: 4px;
      overflow: hidden;
      position: relative;
      
      .curtain-fabric {
        height: 100%;
        background: linear-gradient(90deg, #8B4513 0%, #D2691E 50%, #8B4513 100%);
        transition: width 0.3s ease;
      }
    }
    
    .curtain-percent {
      margin-top: 4px;
      font-size: 12px;
      color: #666;
    }
  }
  
  .curtain-slider {
    margin: 8px 0;
  }
  
  .curtain-buttons {
    display: flex;
    justify-content: space-around;
    gap: 8px;
  }
}
```

## 6. 高级功能

### 6.1 自定义属性编辑器

如果默认的属性编辑器不满足需求，可以扩展 `PropertyEditor.vue`：

```vue
<!-- PropertyEditor.vue 中添加 -->
<template v-else-if="propConfig.type === 'customType'">
  <MyCustomEditor
    :value="widget.props[propKey]"
    :config="propConfig"
    @change="handlePropChange(propKey, $event)"
  />
</template>
```

### 6.2 复杂数据绑定

对于需要复杂数据转换的组件：

```typescript
// 在 WidgetRenderer.vue 中
function transformBindingValue(value: any, widget: any) {
  const binding = widget.binding;
  
  // 值映射
  if (binding?.valueMapping) {
    return binding.valueMapping[value] ?? value;
  }
  
  // 格式化
  if (binding?.format) {
    return binding.format.replace('{value}', value);
  }
  
  // 计算表达式
  if (binding?.expression) {
    // 简单的表达式计算
    return eval(binding.expression.replace('value', value));
  }
  
  return value;
}
```

### 6.3 组件间通信

如果需要组件间通信，可以通过事件总线或状态管理：

```typescript
// 使用 provide/inject
import { provide, inject } from 'vue';

// 父组件提供
provide('panelContext', {
  widgets: widgets,
  updateWidget: (id, data) => { ... },
  broadcastEvent: (event) => { ... },
});

// 子组件注入
const panelContext = inject('panelContext');
```

## 7. 组件开发检查清单

- [ ] 组件定义完整（type, name, category, icon, defaultSize）
- [ ] 属性配置合理（类型、默认值、标签）
- [ ] 数据绑定配置正确
- [ ] 事件配置完整
- [ ] 渲染模板实现
- [ ] 设计模式下禁用交互（isDesign 检查）
- [ ] 影子状态监听和更新
- [ ] 事件触发正确
- [ ] 样式美观且响应式
- [ ] 测试设计器拖拽
- [ ] 测试属性编辑
- [ ] 测试运行时功能

## 8. 常见问题

### Q1: 图标不显示？

确保使用的图标名称在 `@ant-design/icons-vue` 中存在。可以在 [Ant Design Icons](https://ant.design/components/icon-cn) 查看所有可用图标。

### Q2: 组件在设计器中可以交互？

检查是否正确使用了 `isDesign` 属性：
```vue
<a-button :disabled="isDesign" @click="handleClick">
```

### Q3: 数据绑定不生效？

1. 检查 binding 配置是否正确
2. 检查 watch 监听是否正确处理了该组件类型
3. 检查 shadowState 中的数据格式

### Q4: 事件没有触发？

1. 检查 events 配置中的 key 是否正确
2. 检查 triggerEvent 调用是否正确
3. 检查 HTTP 事件配置是否启用
